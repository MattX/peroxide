use std::fmt::Write;

use ast::{MacroSource, Source};
use value::Locator;

/// An error which can provide a code location
pub trait SourcedError: std::error::Error {
    fn code_source(&self) -> Option<&Source>;
}

pub fn locate_message(locator: &Locator, type_: impl AsRef<str>, msg: impl AsRef<str>) -> String {
    error_with_source(&Source::Code(locator.clone()), type_, msg)
}

pub fn error_with_source(source: &Source, type_: impl AsRef<str>, msg: impl AsRef<str>) -> String {
    let mut output = String::new();
    writeln!(output, "{} error: {}", type_.as_ref(), msg.as_ref()).unwrap();
    error_with_source_d(&mut output, source, 0);
    output
}

fn error_with_source_d(output: &mut String, source: &Source, depth: usize) {
    match source {
        Source::Absent => writeln!(output, "{}--> (unknown code location)", depth).unwrap(),
        Source::Code(locator) => locate_in_code(output, locator, depth),
        Source::Macro {
            macro_source,
            code_source,
        } => locate_macro(output, macro_source, code_source, depth),
    }
}

fn locate_in_code(output: &mut String, locator: &Locator, depth: usize) {
    let prefix = " ".repeat(depth * 2);
    let line_number_width = depth * 2 + locator.range.end.0.to_string().chars().count();
    let line_padding = " ".repeat(line_number_width);

    writeln!(output, "{}--> {}", prefix, locator).unwrap();
    writeln!(output, "{} |", line_padding).unwrap();

    for (i_line, line) in locator.file.source.lines().enumerate() {
        if i_line + 1 < locator.range.start.0 as usize {
            continue;
        } else if i_line + 1 > locator.range.end.0 as usize {
            break;
        }
        if i_line + 1 == locator.range.start.0 as usize {
            writeln!(
                output,
                "{:width$} |   {}",
                i_line + 1,
                line,
                width = line_number_width
            )
            .unwrap();
            let marker = if i_line + 1 == locator.range.end.0 as usize {
                let underline =
                    "^".repeat((locator.range.end.1 - locator.range.start.1 + 1) as usize);
                let prefix = " ".repeat((locator.range.start.1 + 1) as usize);
                prefix + &underline
            } else {
                "-".repeat((locator.range.start.1 + 1) as usize) + "^"
            };
            writeln!(output, "{} | {}", line_padding, marker).unwrap();
        } else if i_line + 1 == locator.range.end.0 as usize {
            writeln!(
                output,
                "{:width$} | | {}",
                i_line + 1,
                line,
                width = line_number_width
            )
            .unwrap();
            let marker = "-".repeat((locator.range.end.1 + 1) as usize) + "^";
            writeln!(output, "{} | {}", line_padding, marker).unwrap();
        } else {
            writeln!(
                output,
                "{:width$} | | {}",
                i_line + 1,
                line,
                width = line_number_width
            )
            .unwrap();
        }
    }

    writeln!(output, "{} |", line_padding).unwrap();
}

fn locate_macro(
    output: &mut String,
    macro_source: &MacroSource,
    code_source: &Source,
    depth: usize,
) {
    let prefix: String = " ".repeat(depth * 2);
    writeln!(
        output,
        "{}--> in code generated by macro {}, which is defined",
        prefix, macro_source.name
    )
    .unwrap();
    error_with_source_d(output, &macro_source.source, depth + 1);
    writeln!(output, "{}  > using input defined", prefix).unwrap();
    error_with_source_d(output, code_source, depth + 1);
}
